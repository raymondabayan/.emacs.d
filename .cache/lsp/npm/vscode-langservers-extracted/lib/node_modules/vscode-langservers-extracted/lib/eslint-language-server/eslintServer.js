/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';

require("core-js/modules/es.function.name.js");

require("core-js/modules/es.array.from.js");

require("core-js/modules/es.symbol.js");

require("core-js/modules/es.symbol.description.js");

require("core-js/modules/es.symbol.iterator.js");

require("regenerator-runtime/runtime.js");

require("core-js/modules/es.object.to-string.js");

require("core-js/modules/es.array.iterator.js");

require("core-js/modules/es.set.js");

require("core-js/modules/es.string.iterator.js");

require("core-js/modules/web.dom-collections.iterator.js");

require("core-js/modules/es.map.js");

require("core-js/modules/es.array.filter.js");

require("core-js/modules/web.dom-collections.for-each.js");

require("core-js/modules/es.object.entries.js");

require("core-js/modules/es.regexp.to-string.js");

require("core-js/modules/es.string.starts-with.js");

require("core-js/modules/es.regexp.exec.js");

require("core-js/modules/es.regexp.constructor.js");

require("core-js/modules/es.string.replace.js");

require("core-js/modules/es.array.slice.js");

require("core-js/modules/es.number.is-nan.js");

require("core-js/modules/es.number.constructor.js");

require("core-js/modules/es.array.concat.js");

require("core-js/modules/es.string.trim.js");

require("core-js/modules/es.array.join.js");

require("core-js/modules/es.object.assign.js");

require("core-js/modules/es.promise.js");

require("core-js/modules/es.array.map.js");

require("core-js/modules/es.array.sort.js");

require("core-js/modules/es.string.match.js");

require("core-js/modules/es.object.keys.js");

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var path = require("path");

var fs = require("fs");

var crypto = require("crypto");

var child_process_1 = require("child_process");

var os_1 = require("os");

var node_1 = require("vscode-languageserver/node");

var vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");

var vscode_uri_1 = require("vscode-uri");

var diff_1 = require("./diff");

var linkedMap_1 = require("./linkedMap");

var Is;

(function (Is) {
  var toString = Object.prototype.toString;

  function boolean(value) {
    return value === true || value === false;
  }

  Is.boolean = boolean;

  function nullOrUndefined(value) {
    return value === null || value === undefined;
  }

  Is.nullOrUndefined = nullOrUndefined;

  function string(value) {
    return toString.call(value) === '[object String]';
  }

  Is.string = string;
})(Is || (Is = {}));

var CommandIds;

(function (CommandIds) {
  CommandIds.applySingleFix = 'eslint.applySingleFix';
  CommandIds.applySuggestion = 'eslint.applySuggestion';
  CommandIds.applySameFixes = 'eslint.applySameFixes';
  CommandIds.applyAllFixes = 'eslint.applyAllFixes';
  CommandIds.applyDisableLine = 'eslint.applyDisableLine';
  CommandIds.applyDisableFile = 'eslint.applyDisableFile';
  CommandIds.openRuleDoc = 'eslint.openRuleDoc';
})(CommandIds || (CommandIds = {}));

var Status;

(function (Status) {
  Status[Status["ok"] = 1] = "ok";
  Status[Status["warn"] = 2] = "warn";
  Status[Status["error"] = 3] = "error";
})(Status || (Status = {}));

var StatusNotification;

(function (StatusNotification) {
  StatusNotification.type = new node_1.NotificationType('eslint/status');
})(StatusNotification || (StatusNotification = {}));

var NoConfigRequest;

(function (NoConfigRequest) {
  NoConfigRequest.type = new node_1.RequestType('eslint/noConfig');
})(NoConfigRequest || (NoConfigRequest = {}));

var NoESLintLibraryRequest;

(function (NoESLintLibraryRequest) {
  NoESLintLibraryRequest.type = new node_1.RequestType('eslint/noLibrary');
})(NoESLintLibraryRequest || (NoESLintLibraryRequest = {}));

var OpenESLintDocRequest;

(function (OpenESLintDocRequest) {
  OpenESLintDocRequest.type = new node_1.RequestType('eslint/openDoc');
})(OpenESLintDocRequest || (OpenESLintDocRequest = {}));

var ProbeFailedRequest;

(function (ProbeFailedRequest) {
  ProbeFailedRequest.type = new node_1.RequestType('eslint/probeFailed');
})(ProbeFailedRequest || (ProbeFailedRequest = {}));

var ShowOutputChannel;

(function (ShowOutputChannel) {
  ShowOutputChannel.type = new node_1.NotificationType0('eslint/showOutputChannel');
})(ShowOutputChannel || (ShowOutputChannel = {}));

var ModeEnum;

(function (ModeEnum) {
  ModeEnum["auto"] = "auto";
  ModeEnum["location"] = "location";
})(ModeEnum || (ModeEnum = {}));

(function (ModeEnum) {
  function is(value) {
    return value === ModeEnum.auto || value === ModeEnum.location;
  }

  ModeEnum.is = is;
})(ModeEnum || (ModeEnum = {}));

var ModeItem;

(function (ModeItem) {
  function is(item) {
    var candidate = item;
    return candidate && ModeEnum.is(candidate.mode);
  }

  ModeItem.is = is;
})(ModeItem || (ModeItem = {}));

var DirectoryItem;

(function (DirectoryItem) {
  function is(item) {
    var candidate = item;
    return candidate && Is.string(candidate.directory) && (Is.boolean(candidate['!cwd']) || candidate['!cwd'] === undefined);
  }

  DirectoryItem.is = is;
})(DirectoryItem || (DirectoryItem = {}));

var Validate;

(function (Validate) {
  Validate["on"] = "on";
  Validate["off"] = "off";
  Validate["probe"] = "probe";
})(Validate || (Validate = {}));

var ESLintSeverity;

(function (ESLintSeverity) {
  ESLintSeverity["off"] = "off";
  ESLintSeverity["warn"] = "warn";
  ESLintSeverity["error"] = "error";
})(ESLintSeverity || (ESLintSeverity = {}));

var CodeActionsOnSaveMode;

(function (CodeActionsOnSaveMode) {
  CodeActionsOnSaveMode["all"] = "all";
  CodeActionsOnSaveMode["problems"] = "problems";
})(CodeActionsOnSaveMode || (CodeActionsOnSaveMode = {}));

var RuleSeverity;

(function (RuleSeverity) {
  // Original ESLint values
  RuleSeverity["info"] = "info";
  RuleSeverity["warn"] = "warn";
  RuleSeverity["error"] = "error"; // Added severity override changes

  RuleSeverity["off"] = "off";
  RuleSeverity["default"] = "default";
  RuleSeverity["downgrade"] = "downgrade";
  RuleSeverity["upgrade"] = "upgrade";
})(RuleSeverity || (RuleSeverity = {}));

var TextDocumentSettings;

(function (TextDocumentSettings) {
  function hasLibrary(settings) {
    return settings.library !== undefined;
  }

  TextDocumentSettings.hasLibrary = hasLibrary;
})(TextDocumentSettings || (TextDocumentSettings = {}));

var RuleData;

(function (RuleData) {
  function hasMetaType(value) {
    return value !== undefined && value.type !== undefined;
  }

  RuleData.hasMetaType = hasMetaType;
})(RuleData || (RuleData = {}));

var ESLintModule;

(function (ESLintModule) {
  function hasESLintClass(value) {
    return value.ESLint !== undefined;
  }

  ESLintModule.hasESLintClass = hasESLintClass;

  function hasCLIEngine(value) {
    return value.CLIEngine !== undefined;
  }

  ESLintModule.hasCLIEngine = hasCLIEngine;
})(ESLintModule || (ESLintModule = {}));

var ESLintClass;

(function (ESLintClass) {
  function newESLintClass(library, newOptions, useESLintClass) {
    if (ESLintModule.hasESLintClass(library) && useESLintClass) {
      return new library.ESLint(newOptions);
    }

    if (ESLintModule.hasCLIEngine(library)) {
      return new ESLintClassEmulator(new library.CLIEngine(newOptions));
    }

    return new library.ESLint(newOptions);
  }

  ESLintClass.newESLintClass = newESLintClass;
})(ESLintClass || (ESLintClass = {}));

var CLIEngine;

(function (CLIEngine) {
  function hasRule(value) {
    return value.getRules !== undefined;
  }

  CLIEngine.hasRule = hasRule;
})(CLIEngine || (CLIEngine = {}));
/**
 * ESLint class emulator using CLI Engine.
 */


var ESLintClassEmulator = /*#__PURE__*/function () {
  function ESLintClassEmulator(cli) {
    _classCallCheck(this, ESLintClassEmulator);

    this.cli = cli;
  }

  _createClass(ESLintClassEmulator, [{
    key: "isCLIEngine",
    get: function get() {
      return true;
    }
  }, {
    key: "lintText",
    value: function () {
      var _lintText = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(content, options) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", this.cli.executeOnText(content, options.filePath, options.warnIgnored).results);

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function lintText(_x, _x2) {
        return _lintText.apply(this, arguments);
      }

      return lintText;
    }()
  }, {
    key: "isPathIgnored",
    value: function () {
      var _isPathIgnored = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(path) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.cli.isPathIgnored(path));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function isPathIgnored(_x3) {
        return _isPathIgnored.apply(this, arguments);
      }

      return isPathIgnored;
    }()
  }, {
    key: "getRulesMetaForResults",
    value: function getRulesMetaForResults(_results) {
      if (!CLIEngine.hasRule(this.cli)) {
        return undefined;
      }

      var rules = {};

      var _iterator = _createForOfIteratorHelper(this.cli.getRules()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
              name = _step$value[0],
              rule = _step$value[1];

          if (rule.meta !== undefined) {
            rules[name] = rule.meta;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return rules;
    }
  }, {
    key: "calculateConfigForFile",
    value: function () {
      var _calculateConfigForFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(path) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", typeof this.cli.getConfigForFile === 'function' ? this.cli.getConfigForFile(path) : undefined);

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function calculateConfigForFile(_x4) {
        return _calculateConfigForFile.apply(this, arguments);
      }

      return calculateConfigForFile;
    }()
  }]);

  return ESLintClassEmulator;
}();

var RuleMetaData;

(function (RuleMetaData) {
  var handled = new Set();
  var ruleId2Meta = new Map();

  function capture(eslint, reports) {
    var rulesMetaData;

    if (eslint.isCLIEngine) {
      var toHandle = reports.filter(function (report) {
        return !handled.has(report.filePath);
      });

      if (toHandle.length === 0) {
        return;
      }

      rulesMetaData = typeof eslint.getRulesMetaForResults === 'function' ? eslint.getRulesMetaForResults(toHandle) : undefined;
      toHandle.forEach(function (report) {
        return handled.add(report.filePath);
      });
    } else {
      rulesMetaData = typeof eslint.getRulesMetaForResults === 'function' ? eslint.getRulesMetaForResults(reports) : undefined;
    }

    if (rulesMetaData === undefined) {
      return undefined;
    }

    Object.entries(rulesMetaData).forEach(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          meta = _ref2[1];

      if (ruleId2Meta.has(key)) {
        return;
      }

      if (meta && meta.docs && Is.string(meta.docs.url)) {
        ruleId2Meta.set(key, meta);
      }
    });
  }

  RuleMetaData.capture = capture;

  function clear() {
    handled.clear();
    ruleId2Meta.clear();
  }

  RuleMetaData.clear = clear;

  function getUrl(ruleId) {
    var _ruleId2Meta$get, _ruleId2Meta$get$docs;

    return (_ruleId2Meta$get = ruleId2Meta.get(ruleId)) === null || _ruleId2Meta$get === void 0 ? void 0 : (_ruleId2Meta$get$docs = _ruleId2Meta$get.docs) === null || _ruleId2Meta$get$docs === void 0 ? void 0 : _ruleId2Meta$get$docs.url;
  }

  RuleMetaData.getUrl = getUrl;

  function getType(ruleId) {
    var _ruleId2Meta$get2;

    return (_ruleId2Meta$get2 = ruleId2Meta.get(ruleId)) === null || _ruleId2Meta$get2 === void 0 ? void 0 : _ruleId2Meta$get2.type;
  }

  RuleMetaData.getType = getType;

  function hasRuleId(ruleId) {
    return ruleId2Meta.has(ruleId);
  }

  RuleMetaData.hasRuleId = hasRuleId;
})(RuleMetaData || (RuleMetaData = {}));

function loadNodeModule(moduleName) {
  var r = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require;

  try {
    return r(moduleName);
  } catch (err) {
    if (err.stack) {
      connection.console.error(err.stack.toString());
    }
  }

  return undefined;
}

var ruleSeverityCache = new linkedMap_1.LRUCache(1024);

function asteriskMatches(matcher, ruleId) {
  return matcher.startsWith('!') ? !new RegExp("^".concat(matcher.slice(1).replace(/\*/g, '.*'), "$"), 'g').test(ruleId) : new RegExp("^".concat(matcher.replace(/\*/g, '.*'), "$"), 'g').test(ruleId);
}

function getSeverityOverride(ruleId, customizations) {
  var result = ruleSeverityCache.get(ruleId);

  if (result === null) {
    return undefined;
  }

  if (result !== undefined) {
    return result;
  }

  var _iterator2 = _createForOfIteratorHelper(customizations),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var customization = _step2.value;

      if (asteriskMatches(customization.rule, ruleId)) {
        result = customization.severity;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  if (result === undefined) {
    ruleSeverityCache.set(ruleId, null);
    return undefined;
  }

  ruleSeverityCache.set(ruleId, result);
  return result;
}

var saveRuleConfigCache = new linkedMap_1.LRUCache(128);

function isOff(ruleId, matchers) {
  var _iterator3 = _createForOfIteratorHelper(matchers),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var matcher = _step3.value;

      if (matcher.startsWith('!') && new RegExp("^".concat(matcher.slice(1).replace(/\*/g, '.*'), "$"), 'g').test(ruleId)) {
        return true;
      } else if (new RegExp("^".concat(matcher.replace(/\*/g, '.*'), "$"), 'g').test(ruleId)) {
        return false;
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return true;
}

function getSaveRuleConfig(_x5, _x6) {
  return _getSaveRuleConfig.apply(this, arguments);
}

function _getSaveRuleConfig() {
  _getSaveRuleConfig = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(uri, settings) {
    var filePath, result, rules;
    return regeneratorRuntime.wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            filePath = getFilePath(uri);
            result = saveRuleConfigCache.get(uri);

            if (!(filePath === undefined || result === null)) {
              _context12.next = 4;
              break;
            }

            return _context12.abrupt("return", undefined);

          case 4:
            if (!(result !== undefined)) {
              _context12.next = 6;
              break;
            }

            return _context12.abrupt("return", result);

          case 6:
            rules = settings.codeActionOnSave.rules;
            _context12.next = 9;
            return withESLintClass( /*#__PURE__*/function () {
              var _ref10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(eslint) {
                var config, offRules, onRules, _i2, _Object$keys, ruleId;

                return regeneratorRuntime.wrap(function _callee11$(_context11) {
                  while (1) {
                    switch (_context11.prev = _context11.next) {
                      case 0:
                        if (!(rules === undefined || eslint.isCLIEngine)) {
                          _context11.next = 2;
                          break;
                        }

                        return _context11.abrupt("return", undefined);

                      case 2:
                        _context11.next = 4;
                        return eslint.calculateConfigForFile(filePath);

                      case 4:
                        config = _context11.sent;

                        if (!(config === undefined || config.rules === undefined || config.rules.length === 0)) {
                          _context11.next = 7;
                          break;
                        }

                        return _context11.abrupt("return", undefined);

                      case 7:
                        offRules = new Set();
                        onRules = new Set();

                        if (rules.length === 0) {
                          Object.keys(config.rules).forEach(function (ruleId) {
                            return offRules.add(ruleId);
                          });
                        } else {
                          for (_i2 = 0, _Object$keys = Object.keys(config.rules); _i2 < _Object$keys.length; _i2++) {
                            ruleId = _Object$keys[_i2];

                            if (isOff(ruleId, rules)) {
                              offRules.add(ruleId);
                            } else {
                              onRules.add(ruleId);
                            }
                          }
                        }

                        return _context11.abrupt("return", offRules.size > 0 ? {
                          offRules: offRules,
                          onRules: onRules
                        } : undefined);

                      case 11:
                      case "end":
                        return _context11.stop();
                    }
                  }
                }, _callee11);
              }));

              return function (_x18) {
                return _ref10.apply(this, arguments);
              };
            }(), settings);

          case 9:
            result = _context12.sent;

            if (!(result === undefined || result === null)) {
              _context12.next = 15;
              break;
            }

            saveRuleConfigCache.set(uri, null);
            return _context12.abrupt("return", undefined);

          case 15:
            saveRuleConfigCache.set(uri, result);
            return _context12.abrupt("return", result);

          case 17:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee12);
  }));
  return _getSaveRuleConfig.apply(this, arguments);
}

function makeDiagnostic(settings, problem) {
  var message = problem.message;
  var startLine = typeof problem.line !== 'number' || Number.isNaN(problem.line) ? 0 : Math.max(0, problem.line - 1);
  var startChar = typeof problem.column !== 'number' || Number.isNaN(problem.column) ? 0 : Math.max(0, problem.column - 1);
  var endLine = typeof problem.endLine !== 'number' || Number.isNaN(problem.endLine) ? startLine : Math.max(0, problem.endLine - 1);
  var endChar = typeof problem.endColumn !== 'number' || Number.isNaN(problem.endColumn) ? startChar : Math.max(0, problem.endColumn - 1);
  var override = getSeverityOverride(problem.ruleId, settings.rulesCustomizations);
  var result = {
    message: message,
    severity: convertSeverityToDiagnosticWithOverride(problem.severity, override),
    source: 'eslint',
    range: {
      start: {
        line: startLine,
        character: startChar
      },
      end: {
        line: endLine,
        character: endChar
      }
    }
  };

  if (problem.ruleId) {
    var url = RuleMetaData.getUrl(problem.ruleId);
    result.code = problem.ruleId;

    if (url !== undefined) {
      result.codeDescription = {
        href: url
      };
    }

    if (problem.ruleId === 'no-unused-vars') {
      result.tags = [node_1.DiagnosticTag.Unnecessary];
    }
  }

  return [result, override];
}

var Problem;

(function (Problem) {
  function isFixable(problem) {
    return problem.edit !== undefined;
  }

  Problem.isFixable = isFixable;

  function hasSuggestions(problem) {
    return problem.suggestions !== undefined;
  }

  Problem.hasSuggestions = hasSuggestions;
})(Problem || (Problem = {}));

var FixableProblem;

(function (FixableProblem) {
  function createTextEdit(document, editInfo) {
    return node_1.TextEdit.replace(node_1.Range.create(document.positionAt(editInfo.edit.range[0]), document.positionAt(editInfo.edit.range[1])), editInfo.edit.text || '');
  }

  FixableProblem.createTextEdit = createTextEdit;
})(FixableProblem || (FixableProblem = {}));

var SuggestionsProblem;

(function (SuggestionsProblem) {
  function createTextEdit(document, suggestion) {
    return node_1.TextEdit.replace(node_1.Range.create(document.positionAt(suggestion.fix.range[0]), document.positionAt(suggestion.fix.range[1])), suggestion.fix.text || '');
  }

  SuggestionsProblem.createTextEdit = createTextEdit;
})(SuggestionsProblem || (SuggestionsProblem = {}));

function computeKey(diagnostic) {
  var _message;

  var range = diagnostic.range;
  var message;

  if (diagnostic.message) {
    var hash = crypto.createHash('md5');
    hash.update(diagnostic.message);
    message = hash.digest('base64');
  }

  return "[".concat(range.start.line, ",").concat(range.start.character, ",").concat(range.end.line, ",").concat(range.end.character, "]-").concat(diagnostic.code, "-").concat((_message = message) !== null && _message !== void 0 ? _message : '');
}

var codeActions = new Map();

function recordCodeAction(document, diagnostic, problem) {
  if (!problem.ruleId) {
    return;
  }

  var uri = document.uri;
  var edits = codeActions.get(uri);

  if (edits === undefined) {
    edits = new Map();
    codeActions.set(uri, edits);
  }

  edits.set(computeKey(diagnostic), {
    label: "Fix this ".concat(problem.ruleId, " problem"),
    documentVersion: document.version,
    ruleId: problem.ruleId,
    line: problem.line,
    diagnostic: diagnostic,
    edit: problem.fix,
    suggestions: problem.suggestions
  });
}

function adjustSeverityForOverride(severity, severityOverride) {
  switch (severityOverride) {
    case RuleSeverity.off:
    case RuleSeverity.info:
    case RuleSeverity.warn:
    case RuleSeverity.error:
      return severityOverride;

    case RuleSeverity.downgrade:
      switch (convertSeverityToDiagnostic(severity)) {
        case node_1.DiagnosticSeverity.Error:
          return RuleSeverity.warn;

        case node_1.DiagnosticSeverity.Warning:
        case node_1.DiagnosticSeverity.Information:
          return RuleSeverity.info;
      }

    case RuleSeverity.upgrade:
      switch (convertSeverityToDiagnostic(severity)) {
        case node_1.DiagnosticSeverity.Information:
          return RuleSeverity.warn;

        case node_1.DiagnosticSeverity.Warning:
        case node_1.DiagnosticSeverity.Error:
          return RuleSeverity.error;
      }

    default:
      return severity;
  }
}

function convertSeverityToDiagnostic(severity) {
  // RuleSeverity concerns an overridden rule. A number is direct from ESLint.
  switch (severity) {
    // Eslint 1 is warning
    case 1:
    case RuleSeverity.warn:
      return node_1.DiagnosticSeverity.Warning;

    case 2:
    case RuleSeverity.error:
      return node_1.DiagnosticSeverity.Error;

    case RuleSeverity.info:
      return node_1.DiagnosticSeverity.Information;

    default:
      return node_1.DiagnosticSeverity.Error;
  }
}

function convertSeverityToDiagnosticWithOverride(severity, severityOverride) {
  return convertSeverityToDiagnostic(adjustSeverityForOverride(severity, severityOverride));
}
/**
 * Check if the path follows this pattern: `\\hostname\sharename`.
 *
 * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx
 * @return A boolean indication if the path is a UNC path, on none-windows
 * always false.
 */


function isUNC(path) {
  if (process.platform !== 'win32') {
    // UNC is a windows concept
    return false;
  }

  if (!path || path.length < 5) {
    // at least \\a\b
    return false;
  }

  var code = path.charCodeAt(0);

  if (code !== 92
  /* Backslash */
  ) {
    return false;
  }

  code = path.charCodeAt(1);

  if (code !== 92
  /* Backslash */
  ) {
    return false;
  }

  var pos = 2;
  var start = pos;

  for (; pos < path.length; pos++) {
    code = path.charCodeAt(pos);

    if (code === 92
    /* Backslash */
    ) {
      break;
    }
  }

  if (start === pos) {
    return false;
  }

  code = path.charCodeAt(pos + 1);

  if (isNaN(code) || code === 92
  /* Backslash */
  ) {
    return false;
  }

  return true;
}

function normalizeDriveLetter(path) {
  if (process.platform !== 'win32' || path.length < 2 || path[1] !== ':') {
    return path;
  }

  return path[0].toUpperCase() + path.substr(1);
}

function getFileSystemPath(uri) {
  var result = uri.fsPath;

  if (process.platform === 'win32' && result.length >= 2 && result[1] === ':') {
    // Node by default uses an upper case drive letter and ESLint uses
    // === to compare paths which results in the equal check failing
    // if the drive letter is lower case in th URI. Ensure upper case.
    result = result[0].toUpperCase() + result.substr(1);
  }

  if (process.platform === 'win32' || process.platform === 'darwin') {
    var realpath = fs.realpathSync.native(result); // Only use the real path if only the casing has changed.

    if (realpath.toLowerCase() === result.toLowerCase()) {
      result = realpath;
    }
  }

  return result;
}

function normalizePath(path) {
  if (path === undefined) {
    return undefined;
  }

  if (process.platform === 'win32') {
    return path.replace(/\\/g, '/');
  }

  return path;
}

function getUri(documentOrUri) {
  return Is.string(documentOrUri) ? vscode_uri_1.URI.parse(documentOrUri) : documentOrUri instanceof vscode_uri_1.URI ? documentOrUri : vscode_uri_1.URI.parse(documentOrUri.uri);
}

function getFilePath(documentOrUri) {
  if (!documentOrUri) {
    return undefined;
  }

  var uri = getUri(documentOrUri);

  if (uri.scheme !== 'file') {
    return undefined;
  }

  return getFileSystemPath(uri);
}

var exitCalled = new node_1.NotificationType('eslint/exitCalled');
var nodeExit = process.exit;

process.exit = function (code) {
  var stack = new Error('stack');
  connection.sendNotification(exitCalled, [code ? code : 0, stack.stack]);
  setTimeout(function () {
    nodeExit(code);
  }, 1000);
};

process.on('uncaughtException', function (error) {
  var message;

  if (error) {
    if (typeof error.stack === 'string') {
      message = error.stack;
    } else if (typeof error.message === 'string') {
      message = error.message;
    } else if (typeof error === 'string') {
      message = error;
    }

    if (message === undefined || message.length === 0) {
      try {
        message = JSON.stringify(error, undefined, 4);
      } catch (e) {// Should not happen.
      }
    }
  } // eslint-disable-next-line no-console


  console.error('Uncaught exception received.');

  if (message) {
    // eslint-disable-next-line no-console
    console.error(message);
  }
});

function isRequestMessage(message) {
  var candidate = message;
  return candidate && typeof candidate.method === 'string' && (typeof candidate.id === 'string' || typeof candidate.id === 'number');
}

var connection = (0, node_1.createConnection)({
  cancelUndispatched: function cancelUndispatched(message) {
    // Code actions can savely be cancel on request.
    if (isRequestMessage(message) && message.method === 'textDocument/codeAction') {
      var response = {
        jsonrpc: message.jsonrpc,
        id: message.id,
        result: null
      };
      return response;
    }

    return undefined;
  }
});
connection.console.info("ESLint server running in node ".concat(process.version)); // Is instantiated in the initialize handle;

var documents;
var _globalPaths = {
  yarn: {
    cache: undefined,
    get: function get() {
      return node_1.Files.resolveGlobalYarnPath(trace);
    }
  },
  npm: {
    cache: undefined,
    get: function get() {
      return node_1.Files.resolveGlobalNodePath(trace);
    }
  },
  pnpm: {
    cache: undefined,
    get: function get() {
      var pnpmPath = (0, child_process_1.execSync)('pnpm root -g').toString().trim();
      return pnpmPath;
    }
  }
};

function globalPathGet(packageManager) {
  var pm = _globalPaths[packageManager];

  if (pm) {
    if (pm.cache === undefined) {
      pm.cache = pm.get();
    }

    return pm.cache;
  }

  return undefined;
}

var languageId2Config = new Map([['javascript', {
  ext: 'js',
  lineComment: '//',
  blockComment: ['/*', '*/']
}], ['javascriptreact', {
  ext: 'jsx',
  lineComment: '//',
  blockComment: ['/*', '*/']
}], ['typescript', {
  ext: 'ts',
  lineComment: '//',
  blockComment: ['/*', '*/']
}], ['typescriptreact', {
  ext: 'tsx',
  lineComment: '//',
  blockComment: ['/*', '*/']
}], ['html', {
  ext: 'html',
  lineComment: '//',
  blockComment: ['/*', '*/']
}], ['vue', {
  ext: 'vue',
  lineComment: '//',
  blockComment: ['/*', '*/']
}], ['coffeescript', {
  ext: 'coffee',
  lineComment: '#',
  blockComment: ['###', '###']
}], ['yaml', {
  ext: 'yaml',
  lineComment: '#',
  blockComment: ['#', '']
}], ['graphql', {
  ext: 'graphql',
  lineComment: '#',
  blockComment: ['#', '']
}]]);

function getLineComment(languageId) {
  var _languageId2Config$ge, _languageId2Config$ge2;

  return (_languageId2Config$ge = (_languageId2Config$ge2 = languageId2Config.get(languageId)) === null || _languageId2Config$ge2 === void 0 ? void 0 : _languageId2Config$ge2.lineComment) !== null && _languageId2Config$ge !== void 0 ? _languageId2Config$ge : '//';
}

function getBlockComment(languageId) {
  var _languageId2Config$ge3, _languageId2Config$ge4;

  return (_languageId2Config$ge3 = (_languageId2Config$ge4 = languageId2Config.get(languageId)) === null || _languageId2Config$ge4 === void 0 ? void 0 : _languageId2Config$ge4.blockComment) !== null && _languageId2Config$ge3 !== void 0 ? _languageId2Config$ge3 : ['/**', '*/'];
}

var languageId2ParserRegExp = function createLanguageId2ParserRegExp() {
  var result = new Map();
  var typescript = /\/@typescript-eslint\/parser\//;
  var babelESLint = /\/babel-eslint\/lib\/index.js$/;
  result.set('typescript', [typescript, babelESLint]);
  result.set('typescriptreact', [typescript, babelESLint]);
  var angular = /\/@angular-eslint\/template-parser\//;
  result.set('html', [angular]);
  return result;
}();

var languageId2ParserOptions = function createLanguageId2ParserOptionsRegExp() {
  var result = new Map();
  var vue = /vue-eslint-parser\/.*\.js$/;
  var typescriptEslintParser = /@typescript-eslint\/parser\/.*\.js$/;
  result.set('typescript', {
    regExps: [vue],
    parsers: new Set(['@typescript-eslint/parser']),
    parserRegExps: [typescriptEslintParser]
  });
  return result;
}();

var languageId2PluginName = new Map([['html', 'html'], ['vue', 'vue'], ['markdown', 'markdown']]);
var defaultLanguageIds = new Set(['javascript', 'javascriptreact']);
var path2Library = new Map();
var document2Settings = new Map();
var projectFolderIndicators = [['package.json', true], ['.eslintignore', true], ['.eslintrc', false], ['.eslintrc.json', false], ['.eslintrc.js', false], ['.eslintrc.yaml', false], ['.eslintrc.yml', false]];

function getESLintFilePath(document, settings) {
  if (document === undefined) {
    return undefined;
  }

  var uri = vscode_uri_1.URI.parse(document.uri);

  if (uri.scheme === 'untitled') {
    if (settings.workspaceFolder !== undefined) {
      var ext = languageId2Config.get(document.languageId);
      var workspacePath = getFilePath(settings.workspaceFolder.uri);

      if (workspacePath !== undefined && ext !== undefined) {
        return path.join(workspacePath, "test".concat(ext));
      }
    }

    return undefined;
  } else {
    return getFilePath(uri);
  }
}

function findWorkingDirectory(workspaceFolder, file) {
  if (file === undefined || isUNC(file)) {
    return workspaceFolder;
  } // Don't probe for something in node modules folder.


  if (file.indexOf("".concat(path.sep, "node_modules").concat(path.sep)) !== -1) {
    return workspaceFolder;
  }

  var result = workspaceFolder;
  var directory = path.dirname(file);

  outer: while (directory !== undefined && directory.startsWith(workspaceFolder)) {
    var _iterator4 = _createForOfIteratorHelper(projectFolderIndicators),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var item = _step4.value;

        if (fs.existsSync(path.join(directory, item[0]))) {
          result = directory;

          if (item[1]) {
            break outer;
          } else {
            break;
          }
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    var parent = path.dirname(directory);
    directory = parent !== directory ? parent : undefined;
  }

  return result;
}

function resolveSettings(document) {
  var uri = document.uri;
  var resultPromise = document2Settings.get(uri);

  if (resultPromise) {
    return resultPromise;
  }

  resultPromise = connection.workspace.getConfiguration({
    scopeUri: uri,
    section: ''
  }).then(function (configuration) {
    var _configuration$workin;

    var settings = Object.assign({}, configuration, {
      silent: false,
      library: undefined,
      resolvedGlobalPackageManagerPath: undefined
    }, {
      workingDirectory: undefined
    });

    if (settings.validate === Validate.off) {
      return settings;
    }

    settings.resolvedGlobalPackageManagerPath = globalPathGet(settings.packageManager);
    var filePath = getFilePath(document);
    var workspaceFolderPath = settings.workspaceFolder !== undefined ? getFilePath(settings.workspaceFolder.uri) : undefined;
    var hasUserDefinedWorkingDirectories = configuration.workingDirectory !== undefined;
    var workingDirectoryConfig = (_configuration$workin = configuration.workingDirectory) !== null && _configuration$workin !== void 0 ? _configuration$workin : {
      mode: ModeEnum.location
    };

    if (ModeItem.is(workingDirectoryConfig)) {
      var candidate;

      if (workingDirectoryConfig.mode === ModeEnum.location) {
        if (workspaceFolderPath !== undefined) {
          candidate = workspaceFolderPath;
        } else if (filePath !== undefined && !isUNC(filePath)) {
          candidate = path.dirname(filePath);
        }
      } else if (workingDirectoryConfig.mode === ModeEnum.auto) {
        if (workspaceFolderPath !== undefined) {
          candidate = findWorkingDirectory(workspaceFolderPath, filePath);
        } else if (filePath !== undefined && !isUNC(filePath)) {
          candidate = path.dirname(filePath);
        }
      }

      if (candidate !== undefined && fs.existsSync(candidate)) {
        settings.workingDirectory = {
          directory: candidate
        };
      }
    } else {
      settings.workingDirectory = workingDirectoryConfig;
    }

    var promise;
    var nodePath;

    if (settings.nodePath !== null) {
      nodePath = settings.nodePath;

      if (!path.isAbsolute(nodePath) && workspaceFolderPath !== undefined) {
        nodePath = path.join(workspaceFolderPath, nodePath);
      }
    }

    var moduleResolveWorkingDirectory;

    if (!hasUserDefinedWorkingDirectories && filePath !== undefined) {
      moduleResolveWorkingDirectory = path.dirname(filePath);
    }

    if (moduleResolveWorkingDirectory === undefined && settings.workingDirectory !== undefined && !settings.workingDirectory['!cwd']) {
      moduleResolveWorkingDirectory = settings.workingDirectory.directory;
    }

    if (nodePath !== undefined) {
      promise = node_1.Files.resolve('eslint', nodePath, nodePath, trace).then(undefined, function () {
        return node_1.Files.resolve('eslint', settings.resolvedGlobalPackageManagerPath, moduleResolveWorkingDirectory, trace);
      });
    } else {
      promise = node_1.Files.resolve('eslint', settings.resolvedGlobalPackageManagerPath, moduleResolveWorkingDirectory, trace);
    }

    settings.silent = settings.validate === Validate.probe;
    return promise.then( /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(libraryPath) {
        var library, _filePath, parserRegExps, pluginName, parserOptions, eslintConfig, parser, _eslintConfig$parserO, _iterator5, _step5, regExp, _iterator7, _step7, name, params, Uri, isFile, pattern, filter, options, _filePath2;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                library = path2Library.get(libraryPath);

                if (library === undefined) {
                  library = loadNodeModule(libraryPath);

                  if (library === undefined) {
                    settings.validate = Validate.off;

                    if (!settings.silent) {
                      connection.console.error("Failed to load eslint library from ".concat(libraryPath, ". See output panel for more information."));
                    }
                  } else if (library.CLIEngine === undefined && library.ESLint === undefined) {
                    settings.validate = Validate.off;
                    connection.console.error("The eslint library loaded from ".concat(libraryPath, " doesn't neither exports a CLIEngine nor an ESLint class. You need at least eslint@1.0.0"));
                  } else {
                    connection.console.info("ESLint library loaded from: ".concat(libraryPath));
                    settings.library = library;
                    path2Library.set(libraryPath, library);
                  }
                } else {
                  settings.library = library;
                }

                if (!(settings.validate === Validate.probe && TextDocumentSettings.hasLibrary(settings))) {
                  _context5.next = 60;
                  break;
                }

                settings.validate = Validate.off;
                _filePath = getESLintFilePath(document, settings);

                if (!(_filePath !== undefined)) {
                  _context5.next = 59;
                  break;
                }

                parserRegExps = languageId2ParserRegExp.get(document.languageId);
                pluginName = languageId2PluginName.get(document.languageId);
                parserOptions = languageId2ParserOptions.get(document.languageId);

                if (!defaultLanguageIds.has(document.languageId)) {
                  _context5.next = 13;
                  break;
                }

                settings.validate = Validate.on;
                _context5.next = 59;
                break;

              case 13:
                if (!(parserRegExps !== undefined || pluginName !== undefined || parserOptions !== undefined)) {
                  _context5.next = 59;
                  break;
                }

                _context5.next = 16;
                return withESLintClass(function (eslintClass) {
                  try {
                    return eslintClass.calculateConfigForFile(_filePath);
                  } catch (err) {
                    return undefined;
                  }
                }, settings);

              case 16:
                eslintConfig = _context5.sent;

                if (!(eslintConfig !== undefined)) {
                  _context5.next = 59;
                  break;
                }

                parser = eslintConfig.parser !== null ? normalizePath(eslintConfig.parser) : undefined;

                if (!(parser !== undefined)) {
                  _context5.next = 40;
                  break;
                }

                if (!(parserRegExps !== undefined)) {
                  _context5.next = 39;
                  break;
                }

                _iterator5 = _createForOfIteratorHelper(parserRegExps);
                _context5.prev = 22;

                _iterator5.s();

              case 24:
                if ((_step5 = _iterator5.n()).done) {
                  _context5.next = 31;
                  break;
                }

                regExp = _step5.value;

                if (!regExp.test(parser)) {
                  _context5.next = 29;
                  break;
                }

                settings.validate = Validate.on;
                return _context5.abrupt("break", 31);

              case 29:
                _context5.next = 24;
                break;

              case 31:
                _context5.next = 36;
                break;

              case 33:
                _context5.prev = 33;
                _context5.t0 = _context5["catch"](22);

                _iterator5.e(_context5.t0);

              case 36:
                _context5.prev = 36;

                _iterator5.f();

                return _context5.finish(36);

              case 39:
                if (settings.validate !== Validate.on && parserOptions !== undefined && typeof ((_eslintConfig$parserO = eslintConfig.parserOptions) === null || _eslintConfig$parserO === void 0 ? void 0 : _eslintConfig$parserO.parser) === 'string') {
                  (function () {
                    var eslintConfigParserOptionsParser = normalizePath(eslintConfig.parserOptions.parser);

                    var _iterator6 = _createForOfIteratorHelper(parserOptions.regExps),
                        _step6;

                    try {
                      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                        var _regExp = _step6.value;

                        if (_regExp.test(parser) && (parserOptions.parsers.has(eslintConfig.parserOptions.parser) || parserOptions.parserRegExps !== undefined && parserOptions.parserRegExps.some(function (parserRegExp) {
                          return parserRegExp.test(eslintConfigParserOptionsParser);
                        }))) {
                          settings.validate = Validate.on;
                          break;
                        }
                      }
                    } catch (err) {
                      _iterator6.e(err);
                    } finally {
                      _iterator6.f();
                    }
                  })();
                }

              case 40:
                if (!(settings.validate !== Validate.on && Array.isArray(eslintConfig.plugins) && eslintConfig.plugins.length > 0 && pluginName !== undefined)) {
                  _context5.next = 59;
                  break;
                }

                _iterator7 = _createForOfIteratorHelper(eslintConfig.plugins);
                _context5.prev = 42;

                _iterator7.s();

              case 44:
                if ((_step7 = _iterator7.n()).done) {
                  _context5.next = 51;
                  break;
                }

                name = _step7.value;

                if (!(name === pluginName)) {
                  _context5.next = 49;
                  break;
                }

                settings.validate = Validate.on;
                return _context5.abrupt("break", 51);

              case 49:
                _context5.next = 44;
                break;

              case 51:
                _context5.next = 56;
                break;

              case 53:
                _context5.prev = 53;
                _context5.t1 = _context5["catch"](42);

                _iterator7.e(_context5.t1);

              case 56:
                _context5.prev = 56;

                _iterator7.f();

                return _context5.finish(56);

              case 59:
                if (settings.validate === Validate.off) {
                  params = {
                    textDocument: {
                      uri: document.uri
                    }
                  };
                  void connection.sendRequest(ProbeFailedRequest.type, params);
                }

              case 60:
                if (!(settings.format && settings.validate === Validate.on && TextDocumentSettings.hasLibrary(settings))) {
                  _context5.next = 74;
                  break;
                }

                Uri = vscode_uri_1.URI.parse(uri);
                isFile = Uri.scheme === 'file';
                pattern = isFile ? Uri.fsPath.replace(/\\/g, '/') : Uri.fsPath;
                pattern = pattern.replace(/[\[\]\{\}]/g, '?');
                filter = {
                  scheme: Uri.scheme,
                  pattern: pattern
                };
                options = {
                  documentSelector: [filter]
                };

                if (isFile) {
                  _context5.next = 71;
                  break;
                }

                formatterRegistrations.set(uri, connection.client.register(node_1.DocumentFormattingRequest.type, options));
                _context5.next = 74;
                break;

              case 71:
                _filePath2 = getFilePath(uri);
                _context5.next = 74;
                return withESLintClass( /*#__PURE__*/function () {
                  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(eslintClass) {
                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.next = 2;
                            return eslintClass.isPathIgnored(_filePath2);

                          case 2:
                            if (_context4.sent) {
                              _context4.next = 4;
                              break;
                            }

                            formatterRegistrations.set(uri, connection.client.register(node_1.DocumentFormattingRequest.type, options));

                          case 4:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function (_x8) {
                    return _ref4.apply(this, arguments);
                  };
                }(), settings);

              case 74:
                return _context5.abrupt("return", settings);

              case 75:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[22, 33, 36, 39], [42, 53, 56, 59]]);
      }));

      return function (_x7) {
        return _ref3.apply(this, arguments);
      };
    }(), function () {
      settings.validate = Validate.off;

      if (!settings.silent) {
        void connection.sendRequest(NoESLintLibraryRequest.type, {
          source: {
            uri: document.uri
          }
        });
      }

      return settings;
    });
  });
  document2Settings.set(uri, resultPromise);
  return resultPromise;
}

var Request;

(function (Request) {
  function is(value) {
    var candidate = value;
    return candidate && candidate.token !== undefined && candidate.resolve !== undefined && candidate.reject !== undefined;
  }

  Request.is = is;
})(Request || (Request = {}));

var Thenable;

(function (Thenable) {
  function is(value) {
    var candidate = value;
    return candidate && typeof candidate.then === 'function';
  }

  Thenable.is = is;
})(Thenable || (Thenable = {}));

var BufferedMessageQueue = /*#__PURE__*/function () {
  function BufferedMessageQueue(connection) {
    _classCallCheck(this, BufferedMessageQueue);

    this.connection = connection;
    this.queue = [];
    this.requestHandlers = new Map();
    this.notificationHandlers = new Map();
  }

  _createClass(BufferedMessageQueue, [{
    key: "registerRequest",
    value: function registerRequest(type, handler, versionProvider) {
      var _this = this;

      this.connection.onRequest(type, function (params, token) {
        return new Promise(function (resolve, reject) {
          _this.queue.push({
            method: type.method,
            params: params,
            documentVersion: versionProvider ? versionProvider(params) : undefined,
            resolve: resolve,
            reject: reject,
            token: token
          });

          _this.trigger();
        });
      });
      this.requestHandlers.set(type.method, {
        handler: handler,
        versionProvider: versionProvider
      });
    }
  }, {
    key: "registerNotification",
    value: function registerNotification(type, handler, versionProvider) {
      var _this2 = this;

      connection.onNotification(type, function (params) {
        _this2.queue.push({
          method: type.method,
          params: params,
          documentVersion: versionProvider ? versionProvider(params) : undefined
        });

        _this2.trigger();
      });
      this.notificationHandlers.set(type.method, {
        handler: handler,
        versionProvider: versionProvider
      });
    }
  }, {
    key: "addNotificationMessage",
    value: function addNotificationMessage(type, params, version) {
      this.queue.push({
        method: type.method,
        params: params,
        documentVersion: version
      });
      this.trigger();
    }
  }, {
    key: "onNotification",
    value: function onNotification(type, handler, versionProvider) {
      this.notificationHandlers.set(type.method, {
        handler: handler,
        versionProvider: versionProvider
      });
    }
  }, {
    key: "trigger",
    value: function trigger() {
      var _this3 = this;

      if (this.timer || this.queue.length === 0) {
        return;
      }

      this.timer = setImmediate(function () {
        _this3.timer = undefined;

        _this3.processQueue();

        _this3.trigger();
      });
    }
  }, {
    key: "processQueue",
    value: function processQueue() {
      var message = this.queue.shift();

      if (!message) {
        return;
      }

      if (Request.is(message)) {
        var requestMessage = message;

        if (requestMessage.token.isCancellationRequested) {
          requestMessage.reject(new node_1.ResponseError(node_1.LSPErrorCodes.RequestCancelled, 'Request got cancelled'));
          return;
        }

        var elem = this.requestHandlers.get(requestMessage.method);

        if (elem === undefined) {
          throw new Error("No handler registered");
        }

        if (elem.versionProvider && requestMessage.documentVersion !== undefined && requestMessage.documentVersion !== elem.versionProvider(requestMessage.params)) {
          requestMessage.reject(new node_1.ResponseError(node_1.LSPErrorCodes.RequestCancelled, 'Request got cancelled'));
          return;
        }

        var result = elem.handler(requestMessage.params, requestMessage.token);

        if (Thenable.is(result)) {
          result.then(function (value) {
            requestMessage.resolve(value);
          }, function (error) {
            requestMessage.reject(error);
          });
        } else {
          requestMessage.resolve(result);
        }
      } else {
        var notificationMessage = message;

        var _elem = this.notificationHandlers.get(notificationMessage.method);

        if (_elem === undefined) {
          throw new Error("No handler registered");
        }

        if (_elem.versionProvider && notificationMessage.documentVersion !== undefined && notificationMessage.documentVersion !== _elem.versionProvider(notificationMessage.params)) {
          return;
        }

        _elem.handler(notificationMessage.params);
      }
    }
  }]);

  return BufferedMessageQueue;
}();

var messageQueue = new BufferedMessageQueue(connection);
var formatterRegistrations = new Map();
var ValidateNotification;

(function (ValidateNotification) {
  ValidateNotification.type = new node_1.NotificationType('eslint/validate');
})(ValidateNotification || (ValidateNotification = {}));

messageQueue.onNotification(ValidateNotification.type, function (document) {
  void validateSingle(document, true);
}, function (document) {
  return document.version;
});

function setupDocumentsListeners() {
  // The documents manager listen for text document create, change
  // and close on the connection
  documents.listen(connection);
  documents.onDidOpen(function (event) {
    void resolveSettings(event.document).then(function (settings) {
      if (settings.validate !== Validate.on || !TextDocumentSettings.hasLibrary(settings)) {
        return;
      }

      if (settings.run === 'onSave') {
        messageQueue.addNotificationMessage(ValidateNotification.type, event.document, event.document.version);
      }
    });
  }); // A text document has changed. Validate the document according the run setting.

  documents.onDidChangeContent(function (event) {
    var uri = event.document.uri;
    codeActions.delete(uri);
    void resolveSettings(event.document).then(function (settings) {
      if (settings.validate !== Validate.on || settings.run !== 'onType') {
        return;
      }

      messageQueue.addNotificationMessage(ValidateNotification.type, event.document, event.document.version);
    });
  }); // A text document has been saved. Validate the document according the run setting.

  documents.onDidSave(function (event) {
    void resolveSettings(event.document).then(function (settings) {
      if (settings.validate !== Validate.on || settings.run !== 'onSave') {
        return;
      }

      messageQueue.addNotificationMessage(ValidateNotification.type, event.document, event.document.version);
    });
  });
  documents.onDidClose(function (event) {
    void resolveSettings(event.document).then(function (settings) {
      var uri = event.document.uri;
      document2Settings.delete(uri);
      saveRuleConfigCache.delete(uri);
      codeActions.delete(uri);
      var unregister = formatterRegistrations.get(event.document.uri);

      if (unregister !== undefined) {
        void unregister.then(function (disposable) {
          return disposable.dispose();
        });
        formatterRegistrations.delete(event.document.uri);
      }

      if (settings.validate === Validate.on) {
        connection.sendDiagnostics({
          uri: uri,
          diagnostics: []
        });
      }
    });
  });
}

function environmentChanged() {
  document2Settings.clear();
  ruleSeverityCache.clear();
  saveRuleConfigCache.clear();

  var _iterator8 = _createForOfIteratorHelper(documents.all()),
      _step8;

  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var document = _step8.value;
      messageQueue.addNotificationMessage(ValidateNotification.type, document, document.version);
    }
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }

  var _iterator9 = _createForOfIteratorHelper(formatterRegistrations.values()),
      _step9;

  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var unregistration = _step9.value;
      void unregistration.then(function (disposable) {
        return disposable.dispose();
      });
    }
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }

  formatterRegistrations.clear();
}

function trace(message, verbose) {
  connection.tracer.log(message, verbose);
}

connection.onInitialize(function (_params, _cancel, progress) {
  progress.begin('Initializing ESLint Server');
  var syncKind = node_1.TextDocumentSyncKind.Incremental;
  documents = new node_1.TextDocuments(vscode_languageserver_textdocument_1.TextDocument);
  setupDocumentsListeners();
  progress.done();
  return {
    capabilities: {
      textDocumentSync: {
        openClose: true,
        change: syncKind,
        willSaveWaitUntil: false,
        save: {
          includeText: false
        }
      },
      workspace: {
        workspaceFolders: {
          supported: true
        }
      },
      codeActionProvider: {
        codeActionKinds: [node_1.CodeActionKind.QuickFix, "".concat(node_1.CodeActionKind.SourceFixAll, ".eslint")]
      },
      executeCommandProvider: {
        commands: [CommandIds.applySingleFix, CommandIds.applySuggestion, CommandIds.applySameFixes, CommandIds.applyAllFixes, CommandIds.applyDisableLine, CommandIds.applyDisableFile, CommandIds.openRuleDoc]
      }
    }
  };
});
connection.onInitialized(function () {
  void connection.client.register(node_1.DidChangeConfigurationNotification.type, undefined);
  void connection.client.register(node_1.DidChangeWorkspaceFoldersNotification.type, undefined);
});
messageQueue.registerNotification(node_1.DidChangeConfigurationNotification.type, function (_params) {
  environmentChanged();
});
messageQueue.registerNotification(node_1.DidChangeWorkspaceFoldersNotification.type, function (_params) {
  environmentChanged();
});
var singleErrorHandlers = [tryHandleNoConfig, tryHandleConfigError, tryHandleMissingModule, showErrorMessage];

function validateSingle(document) {
  var publishDiagnostics = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  // We validate document in a queue but open / close documents directly. So we need to deal with the
  // fact that a document might be gone from the server.
  if (!documents.get(document.uri)) {
    return Promise.resolve(undefined);
  }

  return resolveSettings(document).then( /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(settings) {
      var status, _iterator10, _step10, handler;

      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (!(settings.validate !== Validate.on || !TextDocumentSettings.hasLibrary(settings))) {
                _context6.next = 2;
                break;
              }

              return _context6.abrupt("return");

            case 2:
              _context6.prev = 2;
              _context6.next = 5;
              return validate(document, settings, publishDiagnostics);

            case 5:
              connection.sendNotification(StatusNotification.type, {
                uri: document.uri,
                state: Status.ok
              });
              _context6.next = 37;
              break;

            case 8:
              _context6.prev = 8;
              _context6.t0 = _context6["catch"](2);
              // if an exception has occurred while validating clear all errors to ensure
              // we are not showing any stale once
              connection.sendDiagnostics({
                uri: document.uri,
                diagnostics: []
              });

              if (settings.silent) {
                _context6.next = 35;
                break;
              }

              status = undefined;
              _iterator10 = _createForOfIteratorHelper(singleErrorHandlers);
              _context6.prev = 14;

              _iterator10.s();

            case 16:
              if ((_step10 = _iterator10.n()).done) {
                _context6.next = 23;
                break;
              }

              handler = _step10.value;
              status = handler(_context6.t0, document, settings.library);

              if (!status) {
                _context6.next = 21;
                break;
              }

              return _context6.abrupt("break", 23);

            case 21:
              _context6.next = 16;
              break;

            case 23:
              _context6.next = 28;
              break;

            case 25:
              _context6.prev = 25;
              _context6.t1 = _context6["catch"](14);

              _iterator10.e(_context6.t1);

            case 28:
              _context6.prev = 28;

              _iterator10.f();

              return _context6.finish(28);

            case 31:
              status = status || Status.error;
              connection.sendNotification(StatusNotification.type, {
                uri: document.uri,
                state: status
              });
              _context6.next = 37;
              break;

            case 35:
              connection.console.info(getMessage(_context6.t0, document));
              connection.sendNotification(StatusNotification.type, {
                uri: document.uri,
                state: Status.ok
              });

            case 37:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, null, [[2, 8], [14, 25, 28, 31]]);
    }));

    return function (_x9) {
      return _ref5.apply(this, arguments);
    };
  }());
}

function validateMany(documents) {
  documents.forEach(function (document) {
    messageQueue.addNotificationMessage(ValidateNotification.type, document, document.version);
  });
}

function getMessage(err, document) {
  var result = undefined;

  if (typeof err.message === 'string' || err.message instanceof String) {
    result = err.message;
    result = result.replace(/\r?\n/g, ' ');

    if (/^CLI: /.test(result)) {
      result = result.substr(5);
    }
  } else {
    result = "An unknown error occurred while validating document: ".concat(document.uri);
  }

  return result;
}

var validFixTypes = new Set(['problem', 'suggestion', 'layout']);

function validate(_x10, _x11) {
  return _validate.apply(this, arguments);
}

function _validate() {
  _validate = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(document, settings) {
    var publishDiagnostics,
        newOptions,
        fixTypes,
        _iterator17,
        _step17,
        item,
        content,
        uri,
        file,
        _args14 = arguments;

    return regeneratorRuntime.wrap(function _callee14$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            publishDiagnostics = _args14.length > 2 && _args14[2] !== undefined ? _args14[2] : true;
            newOptions = Object.assign(Object.create(null), settings.options);
            fixTypes = undefined;

            if (Array.isArray(newOptions.fixTypes) && newOptions.fixTypes.length > 0) {
              fixTypes = new Set();
              _iterator17 = _createForOfIteratorHelper(newOptions.fixTypes);

              try {
                for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                  item = _step17.value;

                  if (validFixTypes.has(item)) {
                    fixTypes.add(item);
                  }
                }
              } catch (err) {
                _iterator17.e(err);
              } finally {
                _iterator17.f();
              }

              if (fixTypes.size === 0) {
                fixTypes = undefined;
              }
            }

            content = document.getText();
            uri = document.uri;
            file = getESLintFilePath(document, settings);
            _context14.next = 9;
            return withESLintClass( /*#__PURE__*/function () {
              var _ref11 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(eslintClass) {
                var reportResults, diagnostics, docReport;
                return regeneratorRuntime.wrap(function _callee13$(_context13) {
                  while (1) {
                    switch (_context13.prev = _context13.next) {
                      case 0:
                        codeActions.delete(uri);
                        _context13.next = 3;
                        return eslintClass.lintText(content, {
                          filePath: file,
                          warnIgnored: settings.onIgnoredFiles !== ESLintSeverity.off
                        });

                      case 3:
                        reportResults = _context13.sent;
                        RuleMetaData.capture(eslintClass, reportResults);
                        diagnostics = [];

                        if (reportResults && Array.isArray(reportResults) && reportResults.length > 0) {
                          docReport = reportResults[0];

                          if (docReport.messages && Array.isArray(docReport.messages)) {
                            docReport.messages.forEach(function (problem) {
                              if (problem) {
                                var _makeDiagnostic = makeDiagnostic(settings, problem),
                                    _makeDiagnostic2 = _slicedToArray(_makeDiagnostic, 2),
                                    diagnostic = _makeDiagnostic2[0],
                                    override = _makeDiagnostic2[1];

                                if (!(override === RuleSeverity.off || settings.quiet && diagnostic.severity === node_1.DiagnosticSeverity.Warning)) {
                                  diagnostics.push(diagnostic);
                                }

                                if (fixTypes !== undefined && problem.ruleId !== undefined && problem.fix !== undefined) {
                                  var type = RuleMetaData.getType(problem.ruleId);

                                  if (type !== undefined && fixTypes.has(type)) {
                                    recordCodeAction(document, diagnostic, problem);
                                  }
                                } else {
                                  recordCodeAction(document, diagnostic, problem);
                                }
                              }
                            });
                          }
                        }

                        if (publishDiagnostics) {
                          connection.sendDiagnostics({
                            uri: uri,
                            diagnostics: diagnostics
                          });
                        }

                      case 8:
                      case "end":
                        return _context13.stop();
                    }
                  }
                }, _callee13);
              }));

              return function (_x19) {
                return _ref11.apply(this, arguments);
              };
            }(), settings);

          case 9:
          case "end":
            return _context14.stop();
        }
      }
    }, _callee14);
  }));
  return _validate.apply(this, arguments);
}

function withESLintClass(func, settings, options) {
  var newOptions = options === undefined ? Object.assign(Object.create(null), settings.options) : Object.assign(Object.create(null), settings.options, options);
  var cwd = process.cwd();

  try {
    if (settings.workingDirectory) {
      // A lot of libs are sensitive to drive letter casing and assume a
      // capital drive letter. Make sure we support that correctly.
      var newCWD = normalizeDriveLetter(settings.workingDirectory.directory);
      newOptions.cwd = newCWD;

      if (settings.workingDirectory['!cwd'] !== true && fs.existsSync(newCWD)) {
        process.chdir(newCWD);
      }
    }

    var eslintClass = ESLintClass.newESLintClass(settings.library, newOptions, settings.useESLintClass);
    return func(eslintClass);
  } finally {
    if (cwd !== process.cwd()) {
      process.chdir(cwd);
    }
  }
}

var noConfigReported = new Map();

function isNoConfigFoundError(error) {
  var candidate = error;
  return candidate.messageTemplate === 'no-config-found' || candidate.message === 'No ESLint configuration found.';
}

function tryHandleNoConfig(error, document, library) {
  if (!isNoConfigFoundError(error)) {
    return undefined;
  }

  if (!noConfigReported.has(document.uri)) {
    connection.sendRequest(NoConfigRequest.type, {
      message: getMessage(error, document),
      document: {
        uri: document.uri
      }
    }).then(undefined, function () {});
    noConfigReported.set(document.uri, library);
  }

  return Status.warn;
}

var configErrorReported = new Map();

function tryHandleConfigError(error, document, library) {
  if (!error.message) {
    return undefined;
  }

  function handleFileName(filename) {
    if (!configErrorReported.has(filename)) {
      connection.console.error(getMessage(error, document));

      if (!documents.get(vscode_uri_1.URI.file(filename).toString())) {
        connection.window.showInformationMessage(getMessage(error, document));
      }

      configErrorReported.set(filename, library);
    }

    return Status.warn;
  }

  var matches = /Cannot read config file:\s+(.*)\nError:\s+(.*)/.exec(error.message);

  if (matches && matches.length === 3) {
    return handleFileName(matches[1]);
  }

  matches = /(.*):\n\s*Configuration for rule \"(.*)\" is /.exec(error.message);

  if (matches && matches.length === 3) {
    return handleFileName(matches[1]);
  }

  matches = /Cannot find module '([^']*)'\nReferenced from:\s+(.*)/.exec(error.message);

  if (matches && matches.length === 3) {
    return handleFileName(matches[2]);
  }

  return undefined;
}

var missingModuleReported = new Map();

function tryHandleMissingModule(error, document, library) {
  if (!error.message) {
    return undefined;
  }

  function handleMissingModule(plugin, module, error) {
    if (!missingModuleReported.has(plugin)) {
      var fsPath = getFilePath(document);
      missingModuleReported.set(plugin, library);

      if (error.messageTemplate === 'plugin-missing') {
        connection.console.error(['', "".concat(error.message.toString()), "Happened while validating ".concat(fsPath ? fsPath : document.uri), "This can happen for a couple of reasons:", "1. The plugin name is spelled incorrectly in an ESLint configuration file (e.g. .eslintrc).", "2. If ESLint is installed globally, then make sure ".concat(module, " is installed globally as well."), "3. If ESLint is installed locally, then ".concat(module, " isn't installed correctly."), '', "Consider running eslint --debug ".concat(fsPath ? fsPath : document.uri, " from a terminal to obtain a trace about the configuration files used.")].join('\n'));
      } else {
        connection.console.error(["".concat(error.message.toString()), "Happened while validating ".concat(fsPath ? fsPath : document.uri)].join('\n'));
      }
    }

    return Status.warn;
  }

  var matches = /Failed to load plugin (.*): Cannot find module (.*)/.exec(error.message);

  if (matches && matches.length === 3) {
    return handleMissingModule(matches[1], matches[2], error);
  }

  return undefined;
}

var ignoredErrors = new Set();

function showErrorMessage(error, document) {
  var errorMessage = "ESLint: ".concat(getMessage(error, document), ". Please see the 'ESLint' output channel for details.");
  var actions = [{
    title: 'Open Output',
    id: 1
  }, {
    title: 'Ignore for this Session',
    id: 2
  }];

  if (!ignoredErrors.has(errorMessage)) {
    var _connection$window;

    void (_connection$window = connection.window).showErrorMessage.apply(_connection$window, [errorMessage].concat(actions)).then(function (value) {
      if (value !== undefined) {
        if (value.id === 1) {
          connection.sendNotification(ShowOutputChannel.type);
        } else if (value.id === 2) {
          ignoredErrors.add(errorMessage);
        }
      }
    });
  } else {
    connection.console.error(errorMessage);
  }

  if (Is.string(error.stack)) {
    connection.console.error('ESLint stack trace:');
    connection.console.error(error.stack);
  }

  return Status.error;
}

messageQueue.registerNotification(node_1.DidChangeWatchedFilesNotification.type, /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(params) {
    return regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            // A .eslintrc has change. No smartness here.
            // Simply revalidate all file.
            RuleMetaData.clear();
            noConfigReported.clear();
            missingModuleReported.clear();
            document2Settings.clear(); // config files can change plugins and parser.

            ruleSeverityCache.clear();
            saveRuleConfigCache.clear();
            _context8.next = 8;
            return Promise.all(params.changes.map( /*#__PURE__*/function () {
              var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(change) {
                var fsPath, dirname, library, eslintClass;
                return regeneratorRuntime.wrap(function _callee7$(_context7) {
                  while (1) {
                    switch (_context7.prev = _context7.next) {
                      case 0:
                        fsPath = getFilePath(change.uri);

                        if (!(fsPath === undefined || fsPath.length === 0 || isUNC(fsPath))) {
                          _context7.next = 3;
                          break;
                        }

                        return _context7.abrupt("return");

                      case 3:
                        dirname = path.dirname(fsPath);

                        if (!dirname) {
                          _context7.next = 16;
                          break;
                        }

                        library = configErrorReported.get(fsPath);

                        if (!(library !== undefined)) {
                          _context7.next = 16;
                          break;
                        }

                        eslintClass = ESLintClass.newESLintClass(library, {}, false);
                        _context7.prev = 8;
                        _context7.next = 11;
                        return eslintClass.lintText('', {
                          filePath: path.join(dirname, '___test___.js')
                        });

                      case 11:
                        configErrorReported.delete(fsPath);
                        _context7.next = 16;
                        break;

                      case 14:
                        _context7.prev = 14;
                        _context7.t0 = _context7["catch"](8);

                      case 16:
                      case "end":
                        return _context7.stop();
                    }
                  }
                }, _callee7, null, [[8, 14]]);
              }));

              return function (_x13) {
                return _ref7.apply(this, arguments);
              };
            }()));

          case 8:
            validateMany(documents.all());

          case 9:
          case "end":
            return _context8.stop();
        }
      }
    }, _callee8);
  }));

  return function (_x12) {
    return _ref6.apply(this, arguments);
  };
}());

var Fixes = /*#__PURE__*/function () {
  function Fixes(edits) {
    _classCallCheck(this, Fixes);

    this.edits = edits;
  }

  _createClass(Fixes, [{
    key: "isEmpty",
    value: function isEmpty() {
      return this.edits.size === 0;
    }
  }, {
    key: "getDocumentVersion",
    value: function getDocumentVersion() {
      if (this.isEmpty()) {
        throw new Error('No edits recorded.');
      }

      return this.edits.values().next().value.documentVersion;
    }
  }, {
    key: "getScoped",
    value: function getScoped(diagnostics) {
      var result = [];

      var _iterator11 = _createForOfIteratorHelper(diagnostics),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var diagnostic = _step11.value;
          var key = computeKey(diagnostic);
          var editInfo = this.edits.get(key);

          if (editInfo) {
            result.push(editInfo);
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }

      return result;
    }
  }, {
    key: "getAllSorted",
    value: function getAllSorted() {
      var result = [];

      var _iterator12 = _createForOfIteratorHelper(this.edits.values()),
          _step12;

      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
          var value = _step12.value;

          if (Problem.isFixable(value)) {
            result.push(value);
          }
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }

      return result.sort(function (a, b) {
        var d0 = a.edit.range[0] - b.edit.range[0];

        if (d0 !== 0) {
          return d0;
        } // Both edits have now the same start offset.
        // Length of a and length of b


        var al = a.edit.range[1] - a.edit.range[0];
        var bl = b.edit.range[1] - b.edit.range[0]; // Both has the same start offset and length.

        if (al === bl) {
          return 0;
        }

        if (al === 0) {
          return -1;
        }

        if (bl === 0) {
          return 1;
        }

        return al - bl;
      });
    }
  }, {
    key: "getApplicable",
    value: function getApplicable() {
      var sorted = this.getAllSorted();

      if (sorted.length <= 1) {
        return sorted;
      }

      var result = [];
      var last = sorted[0];
      result.push(last);

      for (var i = 1; i < sorted.length; i++) {
        var current = sorted[i];

        if (!Fixes.overlaps(last, current) && !Fixes.sameRange(last, current)) {
          result.push(current);
          last = current;
        }
      }

      return result;
    }
  }], [{
    key: "overlaps",
    value: function overlaps(a, b) {
      return a !== undefined && a.edit.range[1] > b.edit.range[0];
    }
  }, {
    key: "sameRange",
    value: function sameRange(a, b) {
      return a.edit.range[0] === b.edit.range[0] && a.edit.range[1] === b.edit.range[1];
    }
  }]);

  return Fixes;
}();

var CodeActionResult = /*#__PURE__*/function () {
  function CodeActionResult() {
    _classCallCheck(this, CodeActionResult);

    this._actions = new Map();
  }

  _createClass(CodeActionResult, [{
    key: "get",
    value: function get(ruleId) {
      var result = this._actions.get(ruleId);

      if (result === undefined) {
        result = {
          fixes: [],
          suggestions: []
        };

        this._actions.set(ruleId, result);
      }

      return result;
    }
  }, {
    key: "fixAll",
    get: function get() {
      if (this._fixAll === undefined) {
        this._fixAll = [];
      }

      return this._fixAll;
    }
  }, {
    key: "all",
    value: function all() {
      var result = [];

      var _iterator13 = _createForOfIteratorHelper(this._actions.values()),
          _step13;

      try {
        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
          var actions = _step13.value;
          result.push.apply(result, _toConsumableArray(actions.fixes));
          result.push.apply(result, _toConsumableArray(actions.suggestions));

          if (actions.disable) {
            result.push(actions.disable);
          }

          if (actions.fixAll) {
            result.push(actions.fixAll);
          }

          if (actions.disableFile) {
            result.push(actions.disableFile);
          }

          if (actions.showDocumentation) {
            result.push(actions.showDocumentation);
          }
        }
      } catch (err) {
        _iterator13.e(err);
      } finally {
        _iterator13.f();
      }

      if (this._fixAll !== undefined) {
        result.push.apply(result, _toConsumableArray(this._fixAll));
      }

      return result;
    }
  }, {
    key: "length",
    get: function get() {
      var result = 0;

      var _iterator14 = _createForOfIteratorHelper(this._actions.values()),
          _step14;

      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var actions = _step14.value;
          result += actions.fixes.length;
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }

      return result;
    }
  }]);

  return CodeActionResult;
}();

var Changes = /*#__PURE__*/function () {
  function Changes() {
    _classCallCheck(this, Changes);

    this.values = new Map();
    this.uri = undefined;
    this.version = undefined;
  }

  _createClass(Changes, [{
    key: "clear",
    value: function clear(textDocument) {
      if (textDocument === undefined) {
        this.uri = undefined;
        this.version = undefined;
      } else {
        this.uri = textDocument.uri;
        this.version = textDocument.version;
      }

      this.values.clear();
    }
  }, {
    key: "isUsable",
    value: function isUsable(uri, version) {
      return this.uri === uri && this.version === version;
    }
  }, {
    key: "set",
    value: function set(key, change) {
      this.values.set(key, change);
    }
  }, {
    key: "get",
    value: function get(key) {
      return this.values.get(key);
    }
  }]);

  return Changes;
}();

var CommandParams;

(function (CommandParams) {
  function create(textDocument, ruleId, sequence) {
    return {
      uri: textDocument.uri,
      version: textDocument.version,
      ruleId: ruleId,
      sequence: sequence
    };
  }

  CommandParams.create = create;

  function hasRuleId(value) {
    return value.ruleId !== undefined;
  }

  CommandParams.hasRuleId = hasRuleId;
})(CommandParams || (CommandParams = {}));

var changes = new Changes();
var ESLintSourceFixAll = "".concat(node_1.CodeActionKind.SourceFixAll, ".eslint");
messageQueue.registerRequest(node_1.CodeActionRequest.type, function (params) {
  var result = new CodeActionResult();
  var uri = params.textDocument.uri;
  var textDocument = documents.get(uri);

  if (textDocument === undefined) {
    changes.clear(textDocument);
    return result.all();
  }

  function createCodeAction(title, kind, commandId, arg, diagnostic) {
    var command = node_1.Command.create(title, commandId, arg);
    var action = node_1.CodeAction.create(title, command, kind);

    if (diagnostic !== undefined) {
      action.diagnostics = [diagnostic];
    }

    return action;
  }

  function createDisableLineTextEdit(textDocument, editInfo, indentationText) {
    // if the concerned line is not the first  line of the file
    if (editInfo.line - 1 > 0) {
      // check previous line if there is a eslint-disable-next-line comment already present
      var prevLine = textDocument.getText(node_1.Range.create(node_1.Position.create(editInfo.line - 2, 0), node_1.Position.create(editInfo.line - 2, node_1.uinteger.MAX_VALUE)));
      var matched = prevLine && prevLine.match(new RegExp("".concat(getLineComment(textDocument.languageId), " eslint-disable-next-line")));

      if (matched && matched.length) {
        return node_1.TextEdit.insert(node_1.Position.create(editInfo.line - 2, node_1.uinteger.MAX_VALUE), ", ".concat(editInfo.ruleId));
      }
    }

    return node_1.TextEdit.insert(node_1.Position.create(editInfo.line - 1, 0), "".concat(indentationText).concat(getLineComment(textDocument.languageId), " eslint-disable-next-line ").concat(editInfo.ruleId).concat(os_1.EOL));
  }

  function createDisableSameLineTextEdit(textDocument, editInfo) {
    var currentLine = textDocument.getText(node_1.Range.create(node_1.Position.create(editInfo.line - 1, 0), node_1.Position.create(editInfo.line - 1, node_1.uinteger.MAX_VALUE)));
    var matched = currentLine && new RegExp("".concat(getLineComment(textDocument.languageId), " eslint-disable-line")).exec(currentLine);
    var disableRuleContent = matched && matched.length ? ", ".concat(editInfo.ruleId) : " ".concat(getLineComment(textDocument.languageId), " eslint-disable-line ").concat(editInfo.ruleId);
    return node_1.TextEdit.insert(node_1.Position.create(editInfo.line - 1, node_1.uinteger.MAX_VALUE), disableRuleContent);
  }

  function createDisableFileTextEdit(textDocument, editInfo) {
    // If first line contains a shebang, insert on the next line instead.
    var shebang = textDocument.getText(node_1.Range.create(node_1.Position.create(0, 0), node_1.Position.create(0, 2)));
    var line = shebang === '#!' ? 1 : 0;
    var block = getBlockComment(textDocument.languageId);
    return node_1.TextEdit.insert(node_1.Position.create(line, 0), "".concat(block[0], " eslint-disable ").concat(editInfo.ruleId, " ").concat(block[1]).concat(os_1.EOL));
  }

  function getLastEdit(array) {
    var length = array.length;

    if (length === 0) {
      return undefined;
    }

    return array[length - 1];
  }

  return resolveSettings(textDocument).then( /*#__PURE__*/function () {
    var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(settings) {
      var problems, only, isSource, isSourceFixAll, textDocumentIdentifer, edits, fixes, documentVersion, allFixableRuleIds, kind, _iterator15, _step15, _loop, sameProblems, _iterator16, _step16, editInfo, same;

      return regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              if (!(settings.validate !== Validate.on || !TextDocumentSettings.hasLibrary(settings))) {
                _context9.next = 2;
                break;
              }

              return _context9.abrupt("return", result.all());

            case 2:
              problems = codeActions.get(uri); // We validate on type and have no problems ==> nothing to fix.

              if (!(problems === undefined && settings.run === 'onType')) {
                _context9.next = 5;
                break;
              }

              return _context9.abrupt("return", result.all());

            case 5:
              only = params.context.only !== undefined && params.context.only.length > 0 ? params.context.only[0] : undefined;
              isSource = only === node_1.CodeActionKind.Source;
              isSourceFixAll = only === ESLintSourceFixAll || only === node_1.CodeActionKind.SourceFixAll;

              if (!(isSourceFixAll || isSource)) {
                _context9.next = 19;
                break;
              }

              if (!(isSourceFixAll && settings.codeActionOnSave.enable)) {
                _context9.next = 17;
                break;
              }

              textDocumentIdentifer = {
                uri: textDocument.uri,
                version: textDocument.version
              };
              _context9.next = 13;
              return computeAllFixes(textDocumentIdentifer, AllFixesMode.onSave);

            case 13:
              edits = _context9.sent;

              if (edits !== undefined) {
                result.fixAll.push(node_1.CodeAction.create("Fix all ESLint auto-fixable problems", {
                  documentChanges: [node_1.TextDocumentEdit.create(textDocumentIdentifer, edits)]
                }, ESLintSourceFixAll));
              }

              _context9.next = 18;
              break;

            case 17:
              if (isSource) {
                result.fixAll.push(createCodeAction("Fix all ESLint auto-fixable problems", node_1.CodeActionKind.Source, CommandIds.applyAllFixes, CommandParams.create(textDocument)));
              }

            case 18:
              return _context9.abrupt("return", result.all());

            case 19:
              if (!(problems === undefined)) {
                _context9.next = 21;
                break;
              }

              return _context9.abrupt("return", result.all());

            case 21:
              fixes = new Fixes(problems);

              if (!fixes.isEmpty()) {
                _context9.next = 24;
                break;
              }

              return _context9.abrupt("return", result.all());

            case 24:
              documentVersion = -1;
              allFixableRuleIds = [];
              kind = only !== null && only !== void 0 ? only : node_1.CodeActionKind.QuickFix;
              _iterator15 = _createForOfIteratorHelper(fixes.getScoped(params.context.diagnostics));

              try {
                _loop = function _loop() {
                  var editInfo = _step15.value;
                  documentVersion = editInfo.documentVersion;
                  var ruleId = editInfo.ruleId;
                  allFixableRuleIds.push(ruleId);

                  if (Problem.isFixable(editInfo)) {
                    var workspaceChange = new node_1.WorkspaceChange();
                    workspaceChange.getTextEditChange({
                      uri: uri,
                      version: documentVersion
                    }).add(FixableProblem.createTextEdit(textDocument, editInfo));
                    changes.set("".concat(CommandIds.applySingleFix, ":").concat(ruleId), workspaceChange);
                    var action = createCodeAction(editInfo.label, kind, CommandIds.applySingleFix, CommandParams.create(textDocument, ruleId), editInfo.diagnostic);
                    action.isPreferred = true;
                    result.get(ruleId).fixes.push(action);
                  }

                  if (Problem.hasSuggestions(editInfo)) {
                    editInfo.suggestions.forEach(function (suggestion, suggestionSequence) {
                      var workspaceChange = new node_1.WorkspaceChange();
                      workspaceChange.getTextEditChange({
                        uri: uri,
                        version: documentVersion
                      }).add(SuggestionsProblem.createTextEdit(textDocument, suggestion));
                      changes.set("".concat(CommandIds.applySuggestion, ":").concat(ruleId, ":").concat(suggestionSequence), workspaceChange);
                      var action = createCodeAction("".concat(suggestion.desc, " (").concat(editInfo.ruleId, ")"), node_1.CodeActionKind.QuickFix, CommandIds.applySuggestion, CommandParams.create(textDocument, ruleId, suggestionSequence), editInfo.diagnostic);
                      result.get(ruleId).suggestions.push(action);
                    });
                  }

                  if (settings.codeAction.disableRuleComment.enable) {
                    var _workspaceChange = new node_1.WorkspaceChange();

                    if (settings.codeAction.disableRuleComment.location === 'sameLine') {
                      _workspaceChange.getTextEditChange({
                        uri: uri,
                        version: documentVersion
                      }).add(createDisableSameLineTextEdit(textDocument, editInfo));
                    } else {
                      var lineText = textDocument.getText(node_1.Range.create(node_1.Position.create(editInfo.line - 1, 0), node_1.Position.create(editInfo.line - 1, node_1.uinteger.MAX_VALUE)));
                      var matches = /^([ \t]*)/.exec(lineText);
                      var indentationText = matches !== null && matches.length > 0 ? matches[1] : '';

                      _workspaceChange.getTextEditChange({
                        uri: uri,
                        version: documentVersion
                      }).add(createDisableLineTextEdit(textDocument, editInfo, indentationText));
                    }

                    changes.set("".concat(CommandIds.applyDisableLine, ":").concat(ruleId), _workspaceChange);
                    result.get(ruleId).disable = createCodeAction("Disable ".concat(ruleId, " for this line"), kind, CommandIds.applyDisableLine, CommandParams.create(textDocument, ruleId));

                    if (result.get(ruleId).disableFile === undefined) {
                      _workspaceChange = new node_1.WorkspaceChange();

                      _workspaceChange.getTextEditChange({
                        uri: uri,
                        version: documentVersion
                      }).add(createDisableFileTextEdit(textDocument, editInfo));

                      changes.set("".concat(CommandIds.applyDisableFile, ":").concat(ruleId), _workspaceChange);
                      result.get(ruleId).disableFile = createCodeAction("Disable ".concat(ruleId, " for the entire file"), kind, CommandIds.applyDisableFile, CommandParams.create(textDocument, ruleId));
                    }
                  }

                  if (settings.codeAction.showDocumentation.enable && result.get(ruleId).showDocumentation === undefined) {
                    if (RuleMetaData.hasRuleId(ruleId)) {
                      result.get(ruleId).showDocumentation = createCodeAction("Show documentation for ".concat(ruleId), kind, CommandIds.openRuleDoc, CommandParams.create(textDocument, ruleId));
                    }
                  }
                };

                for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                  _loop();
                }
              } catch (err) {
                _iterator15.e(err);
              } finally {
                _iterator15.f();
              }

              if (result.length > 0) {
                sameProblems = new Map(allFixableRuleIds.map(function (s) {
                  return [s, []];
                }));
                _iterator16 = _createForOfIteratorHelper(fixes.getAllSorted());

                try {
                  for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                    editInfo = _step16.value;

                    if (documentVersion === -1) {
                      documentVersion = editInfo.documentVersion;
                    }

                    if (sameProblems.has(editInfo.ruleId)) {
                      same = sameProblems.get(editInfo.ruleId);

                      if (!Fixes.overlaps(getLastEdit(same), editInfo)) {
                        same.push(editInfo);
                      }
                    }
                  }
                } catch (err) {
                  _iterator16.e(err);
                } finally {
                  _iterator16.f();
                }

                sameProblems.forEach(function (same, ruleId) {
                  if (same.length > 1) {
                    var sameFixes = new node_1.WorkspaceChange();
                    var sameTextChange = sameFixes.getTextEditChange({
                      uri: uri,
                      version: documentVersion
                    });
                    same.map(function (fix) {
                      return FixableProblem.createTextEdit(textDocument, fix);
                    }).forEach(function (edit) {
                      return sameTextChange.add(edit);
                    });
                    changes.set(CommandIds.applySameFixes, sameFixes);
                    result.get(ruleId).fixAll = createCodeAction("Fix all ".concat(ruleId, " problems"), kind, CommandIds.applySameFixes, CommandParams.create(textDocument));
                  }
                });
                result.fixAll.push(createCodeAction("Fix all auto-fixable problems", kind, CommandIds.applyAllFixes, CommandParams.create(textDocument)));
              }

              return _context9.abrupt("return", result.all());

            case 31:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    }));

    return function (_x14) {
      return _ref8.apply(this, arguments);
    };
  }());
}, function (params) {
  var document = documents.get(params.textDocument.uri);
  return document !== undefined ? document.version : undefined;
});
var AllFixesMode;

(function (AllFixesMode) {
  AllFixesMode["onSave"] = "onsave";
  AllFixesMode["format"] = "format";
  AllFixesMode["command"] = "command";
})(AllFixesMode || (AllFixesMode = {}));

function computeAllFixes(_x15, _x16) {
  return _computeAllFixes.apply(this, arguments);
}

function _computeAllFixes() {
  _computeAllFixes = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(identifier, mode) {
    var uri, textDocument, settings, filePath, problems, originalContent, start, result, saveConfig, offRules, onRules, overrideConfig, _iterator18, _step18, ruleId;

    return regeneratorRuntime.wrap(function _callee16$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            uri = identifier.uri;
            textDocument = documents.get(uri);

            if (!(textDocument === undefined || identifier.version !== textDocument.version)) {
              _context16.next = 4;
              break;
            }

            return _context16.abrupt("return", undefined);

          case 4:
            _context16.next = 6;
            return resolveSettings(textDocument);

          case 6:
            settings = _context16.sent;

            if (!(settings.validate !== Validate.on || !TextDocumentSettings.hasLibrary(settings) || mode === AllFixesMode.format && !settings.format)) {
              _context16.next = 9;
              break;
            }

            return _context16.abrupt("return", []);

          case 9:
            filePath = getFilePath(textDocument);
            problems = codeActions.get(uri);
            originalContent = textDocument.getText();
            start = Date.now(); // Only use known fixes when running in onSave mode. See https://github.com/microsoft/vscode-eslint/issues/871
            // for details

            if (!(mode === AllFixesMode.onSave && settings.codeActionOnSave.mode === CodeActionsOnSaveMode.problems)) {
              _context16.next = 19;
              break;
            }

            result = problems !== undefined && problems.size > 0 ? new Fixes(problems).getApplicable().map(function (fix) {
              return FixableProblem.createTextEdit(textDocument, fix);
            }) : [];
            connection.tracer.log("Computing all fixes took: ".concat(Date.now() - start, " ms."));
            return _context16.abrupt("return", result);

          case 19:
            if (!(filePath !== undefined && mode === AllFixesMode.onSave)) {
              _context16.next = 25;
              break;
            }

            _context16.next = 22;
            return getSaveRuleConfig(uri, settings);

          case 22:
            _context16.t0 = _context16.sent;
            _context16.next = 26;
            break;

          case 25:
            _context16.t0 = undefined;

          case 26:
            saveConfig = _context16.t0;
            offRules = saveConfig === null || saveConfig === void 0 ? void 0 : saveConfig.offRules;
            onRules = saveConfig === null || saveConfig === void 0 ? void 0 : saveConfig.onRules;

            if (offRules !== undefined) {
              overrideConfig = {
                rules: Object.create(null)
              };
              _iterator18 = _createForOfIteratorHelper(offRules);

              try {
                for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
                  ruleId = _step18.value;
                  overrideConfig.rules[ruleId] = 'off';
                }
              } catch (err) {
                _iterator18.e(err);
              } finally {
                _iterator18.f();
              }
            }

            return _context16.abrupt("return", withESLintClass( /*#__PURE__*/function () {
              var _ref12 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(eslintClass) {
                var result, fixes, filtered, _iterator19, _step19, _step19$value, key, problem, content, reportResults, fixedContent, diffs, _iterator20, _step20, diff;

                return regeneratorRuntime.wrap(function _callee15$(_context15) {
                  while (1) {
                    switch (_context15.prev = _context15.next) {
                      case 0:
                        result = [];

                        if (problems !== undefined && problems.size > 0) {
                          // We have override rules that turn rules off. Filter the fixes for these rules.
                          if (offRules !== undefined) {
                            filtered = new Map();
                            _iterator19 = _createForOfIteratorHelper(problems);

                            try {
                              for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                                _step19$value = _slicedToArray(_step19.value, 2), key = _step19$value[0], problem = _step19$value[1];

                                if (onRules !== null && onRules !== void 0 && onRules.has(problem.ruleId)) {
                                  filtered.set(key, problem);
                                }
                              }
                            } catch (err) {
                              _iterator19.e(err);
                            } finally {
                              _iterator19.f();
                            }

                            fixes = filtered.size > 0 ? new Fixes(filtered).getApplicable().map(function (fix) {
                              return FixableProblem.createTextEdit(textDocument, fix);
                            }) : undefined;
                          } else {
                            fixes = new Fixes(problems).getApplicable().map(function (fix) {
                              return FixableProblem.createTextEdit(textDocument, fix);
                            });
                          }
                        }

                        content = fixes !== undefined ? vscode_languageserver_textdocument_1.TextDocument.applyEdits(textDocument, fixes) : originalContent;
                        _context15.next = 5;
                        return eslintClass.lintText(content, {
                          filePath: filePath
                        });

                      case 5:
                        reportResults = _context15.sent;
                        connection.tracer.log("Computing all fixes took: ".concat(Date.now() - start, " ms."));

                        if (Array.isArray(reportResults) && reportResults.length === 1 && reportResults[0].output !== undefined) {
                          fixedContent = reportResults[0].output;
                          start = Date.now();
                          diffs = (0, diff_1.stringDiff)(originalContent, fixedContent, false);
                          connection.tracer.log("Computing minimal edits took: ".concat(Date.now() - start, " ms."));
                          _iterator20 = _createForOfIteratorHelper(diffs);

                          try {
                            for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
                              diff = _step20.value;
                              result.push({
                                range: {
                                  start: textDocument.positionAt(diff.originalStart),
                                  end: textDocument.positionAt(diff.originalStart + diff.originalLength)
                                },
                                newText: fixedContent.substr(diff.modifiedStart, diff.modifiedLength)
                              });
                            }
                          } catch (err) {
                            _iterator20.e(err);
                          } finally {
                            _iterator20.f();
                          }
                        } else if (fixes !== undefined) {
                          result.push.apply(result, _toConsumableArray(fixes));
                        }

                        return _context15.abrupt("return", result);

                      case 9:
                      case "end":
                        return _context15.stop();
                    }
                  }
                }, _callee15);
              }));

              return function (_x20) {
                return _ref12.apply(this, arguments);
              };
            }(), settings, overrideConfig !== undefined ? {
              fix: true,
              overrideConfig: overrideConfig
            } : {
              fix: true
            }));

          case 31:
          case "end":
            return _context16.stop();
        }
      }
    }, _callee16);
  }));
  return _computeAllFixes.apply(this, arguments);
}

messageQueue.registerRequest(node_1.ExecuteCommandRequest.type, /*#__PURE__*/function () {
  var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(params) {
    var workspaceChange, commandParams, edits, textChange, url;
    return regeneratorRuntime.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            commandParams = params.arguments[0];

            if (!(params.command === CommandIds.applyAllFixes)) {
              _context10.next = 8;
              break;
            }

            _context10.next = 4;
            return computeAllFixes(commandParams, AllFixesMode.command);

          case 4:
            edits = _context10.sent;

            if (edits !== undefined) {
              workspaceChange = new node_1.WorkspaceChange();
              textChange = workspaceChange.getTextEditChange(commandParams);
              edits.forEach(function (edit) {
                return textChange.add(edit);
              });
            }

            _context10.next = 9;
            break;

          case 8:
            if ([CommandIds.applySingleFix, CommandIds.applyDisableLine, CommandIds.applyDisableFile].indexOf(params.command) !== -1) {
              workspaceChange = changes.get("".concat(params.command, ":").concat(commandParams.ruleId));
            } else if ([CommandIds.applySuggestion].indexOf(params.command) !== -1) {
              workspaceChange = changes.get("".concat(params.command, ":").concat(commandParams.ruleId, ":").concat(commandParams.sequence));
            } else if (params.command === CommandIds.openRuleDoc && CommandParams.hasRuleId(commandParams)) {
              url = RuleMetaData.getUrl(commandParams.ruleId);

              if (url) {
                void connection.sendRequest(OpenESLintDocRequest.type, {
                  url: url
                });
              }
            } else {
              workspaceChange = changes.get(params.command);
            }

          case 9:
            if (!(workspaceChange === undefined)) {
              _context10.next = 11;
              break;
            }

            return _context10.abrupt("return", {});

          case 11:
            return _context10.abrupt("return", connection.workspace.applyEdit(workspaceChange.edit).then(function (response) {
              if (!response.applied) {
                connection.console.error("Failed to apply command: ".concat(params.command));
              }

              return {};
            }, function () {
              connection.console.error("Failed to apply command: ".concat(params.command));
            }));

          case 12:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  }));

  return function (_x17) {
    return _ref9.apply(this, arguments);
  };
}(), function (params) {
  var commandParam = params.arguments[0];

  if (changes.isUsable(commandParam.uri, commandParam.version)) {
    return commandParam.version;
  } else {
    return undefined;
  }
});
messageQueue.registerRequest(node_1.DocumentFormattingRequest.type, function (params) {
  var textDocument = documents.get(params.textDocument.uri);

  if (textDocument === undefined) {
    return [];
  }

  return computeAllFixes({
    uri: textDocument.uri,
    version: textDocument.version
  }, AllFixesMode.format);
}, function (params) {
  var document = documents.get(params.textDocument.uri);
  return document !== undefined ? document.version : undefined;
});
connection.listen();